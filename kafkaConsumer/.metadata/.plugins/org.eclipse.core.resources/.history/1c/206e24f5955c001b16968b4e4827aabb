package consumer;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Properties;
import java.util.concurrent.CountDownLatch;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.KafkaStreams;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.StreamsConfig;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.KTable;
import org.apache.kafka.streams.kstream.Produced;


	public class ConsumerMain {

		  public static final String INPUT_TOPIC = "streams-plaintext-input";
		  public static final String OUTPUT_TOPIC = "streams-wordcount-output";
	
		  static Properties getStreamsConfig(final String[] args) throws IOException {
		  final Properties props = new Properties();
		    if (args != null && args.length > 0) {
		        try (final FileInputStream fis = new FileInputStream(args[0])) {
		            props.load(fis);
		        }
		        if (args.length > 1) {
		            System.out.println("Warning: Some command line arguments were ignored. This demo only accepts an optional configuration file.");
		        }
		    }
		    props.putIfAbsent(StreamsConfig.APPLICATION_ID_CONFIG, "streams-wordcount");
		    props.putIfAbsent(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
		    props.putIfAbsent(StreamsConfig.CACHE_MAX_BYTES_BUFFERING_CONFIG, 0);
		    props.putIfAbsent(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());
		    props.putIfAbsent(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());
		
		    // setting offset reset to earliest so that we can re-run the demo code with the same pre-loaded data
		    // Note: To re-run the demo, you need to use the offset reset tool:
		    // https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Streams+Application+Reset+Tool
		    props.putIfAbsent(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
		    return props;
	}

	static void createWordCountStream(final StreamsBuilder builder) {
	    final KStream<String, String> source = builder.stream(INPUT_TOPIC);
	
	    final KTable<String, Long> counts = source
	        .flatMapValues(value -> Arrays.asList(value.toLowerCase(Locale.getDefault()).split(" ")))
	        .groupBy((key, value) -> value)
	        .count();
	
	    // need to override value serde to Long type
	    counts.toStream().to(OUTPUT_TOPIC, Produced.with(Serdes.String(), Serdes.Long()));
    }
	
	
		    public static void main(final String[] args) throws IOException {
		        final Properties props = getStreamsConfig(args);
	
		        final StreamsBuilder builder = new StreamsBuilder();
		        createWordCountStream(builder);
		        final KafkaStreams streams = new KafkaStreams(builder.build(), props);
		        final CountDownLatch latch = new CountDownLatch(1);
	
		        // attach shutdown handler to catch control-c
		        Runtime.getRuntime().addShutdownHook(new Thread("streams-wordcount-shutdown-hook") {
		            @Override
		            public void run() {
		                streams.close();
		                latch.countDown();
		            }
		        });
	
		        try {
		            streams.start();
		            latch.await();
		        } catch (final Throwable e) {
		            System.exit(1);
		        }
		        System.exit(0);
		    }
	
	
	
	//	public static void main(String[] args) {
//		// TODO Auto-generated method stub
//
//		try {
//			  //Kafka consumer configuration settings
//		      String topicName = "TestTopic";
//		      Properties props = new Properties();
//		      
//		      props.put("bootstrap.servers", "localhost:9092");
//		      props.put("group.id", "test");
//		      props.put("enable.auto.commit", "true");
//		      props.put("auto.commit.interval.ms", "1000");
//		      props.put("session.timeout.ms", "30000");
//		      props.put("key.deserializer", 
//		         "org.apache.kafka.common.serialization.StringDeserializer");
//		      props.put("value.deserializer", 
//		         "org.apache.kafka.common.serialization.StringDeserializer");
////		      KafkaConsumer<String, String> consumer = new KafkaConsumer
////		         <String, String>(props);
//		      
//		      KStreamBuilder builder = new KStreamBuilder();
//
//		      KStream<String, String> addressUpdates = builder
//		          .stream("address-updates");
//
//		      KTable<String, SalesTax> salesTaxes = builder
//		          .table(Serdes.String(), new SalesTaxSerde(), "sales-taxes");
//
//		      addressUpdates
//		          .selectKey((key, value) -> value.getStateCode())
//		          .join(salesTaxes, (addressUpdateMessage, salesTax) -> {
//		              addressUpdateMessage.setSalesTax(salesTax.getTax());
//		              return addressUpdateMessage;
//		          })
//		          .selectKey((key, value) -> value.getId())
//		          .to("address-updates-enriched");
//
//		      KafkaStreams streams = new KafkaStreams(builder, getSettings());
//		      streams.start();
//		      
//		} catch (Exception e) {
//			e.getStackTrace();
//		}
//		
//	}
	
	public static void mainConsumer(String[] args) {
		// TODO Auto-generated method stub

		try {
			  //Kafka consumer configuration settings
		      String topicName = "TestTopic";
		      Properties props = new Properties();
		      
		      props.put("bootstrap.servers", "localhost:9092");
		      props.put("group.id", "test");
		      props.put("enable.auto.commit", "true");
		      props.put("auto.commit.interval.ms", "1000");
		      props.put("session.timeout.ms", "30000");
		      props.put("key.deserializer", 
		         "org.apache.kafka.common.serialization.StringDeserializer");
		      props.put("value.deserializer", 
		         "org.apache.kafka.common.serialization.StringDeserializer");
		      KafkaConsumer<String, String> consumer = new KafkaConsumer
		         <String, String>(props);
		      
		      //Kafka Consumer subscribes list of topics here.
		      consumer.subscribe(Arrays.asList(topicName));
		      
		      //print the topic name
		      System.out.println("Subscribed to topic " + topicName);
		      int i = 0;
		      
		      while (true) {
		         ConsumerRecords<String, String> records = consumer.poll(100);
		         for (ConsumerRecord<String, String> record : records)
		         
		         // print the offset,key and value for the consumer records.
		         System.out.printf("offset = %d, key = %s, value = %s\n", 
		            record.offset(), record.key(), record.value());
		      }
		      
		} catch (Exception e) {
			e.getStackTrace();
		}
		
	}

}
